// import { gsap } from 'gsap';
import hljs from 'highlight.js';
import javascript from 'highlight.js/lib/languages/javascript';
import swift from 'highlight.js/lib/languages/swift';
import 'highlight.js/styles/dark.css';
import postscribe from 'postscribe';
import showdown from 'showdown';

import './css/code.css';

window.Webflow ||= [];
window.Webflow.push(() => {
  //Blog post page code

  function loadGist(el) {
    let match = el.innerHTML.match(/^(https:\/\/gist.*)(\.js)?$/);
    if (!match) {
      return;
    }
    if (el.tagName === 'A') {
      // showdown mode. need to go up one level above the <a> tag
      el = el.parentElement;
    }
    el.innerHTML = '';
    postscribe(el, '<script src=' + match[1] + '.js></script>');
  }

  function formatCode(el) {
    // in "basic html" environments, (for example, testing
    // in a repl) we should use the innerHTML function
    // to get at the raw text we want to modify and highlight.
    // but in webflow, the rtf field inserts <br> tags
    // and escapes entities, and showdown escapes html entities,
    // so in those cases the easiest way to get "clean"
    // text is the innerText function.
    let showdownMode = el.tagName === 'CODE',
      accessor = 'innerHTML';
    if (!showdownMode || el.innerText.split('\n').length > 1) {
      accessor = 'innerText';
    }
    // find our magic declaration string. if we don't find it,
    // do nothing
    let match = el[accessor].match(/--\s*CODE\s+(.*)\s?--/),
      classNames,
      codeEl;
    if (match && match[1]) {
      classNames = match[1];
    } else {
      return;
    }
    // strip off the magic string, everything preceding it, and
    // all leading and trailing whitespace
    let txt = el[accessor].substring(match.index + match[0].length).trim();
    el.innerHTML = '';
    if (classNames.match(/language-markup/)) {
      codeEl = document.createElement('script');
      codeEl.type = 'text/plain';
    } else {
      codeEl = document.createElement('pre').appendChild(document.createElement('code'));
    }
    codeEl.className = classNames.trim();
    if (showdownMode) {
      // go up two levels to replace the <pre><code> generated by showdown
      el.parentElement.parentElement.replaceChild(codeEl.parentElement || codeEl, el.parentElement);
    } else {
      // go up one level to replace the <p> generated by webflow
      el.parentElement.replaceChild(codeEl, el);
    }
    codeEl.innerHTML = txt;
  }

  function rtfToMarkdown(txt) {
    txt = txt.replace(/<p>/g, '');
    txt = txt.replace(/<\/p>/g, '\n\n');
    txt = txt.replace(/<br>/g, '\n');
    txt = txt.replace(/&nbsp;/g, ' ');
    txt = txt.replace(/&lt;/g, '<');
    txt = txt.replace(/&gt;/g, '>');
    txt = txt.replace(/&amp;lt;/g, '&lt;');
    return txt;
  }

  function markdownToHtml(txt) {
    let converter = new showdown.Converter({
      noHeaderId: true,
      headerLevelStart: 1,
      literalMidWordUnderscores: true,
      simpleLineBreaks: false, // you might want to set this option to false to ensure that Showdown.js handles line breaks correctly
    });
    let html = converter.makeHtml(txt);
    // console.log(html);
    return html;
  }

  // if there are elements with a class named 'markdown'
  // attached, first convert their content to html
  let markdowns = [...document.querySelectorAll('.markdown')];

  markdowns.forEach((el) => {
    let txt = rtfToMarkdown(el.innerHTML);

    // Parse content inside <aside> tags
    txt = txt.replace(/<aside>([\s\S]*?)<\/aside>/g, (match, asideContent) => {
      // Convert aside content to markdown and then back to html
      let markdown = rtfToMarkdown(asideContent);
      let html = markdownToHtml(markdown);
      // Return the converted html wrapped in <aside> tags
      return `<aside>${html}</aside>`;
    });

    // Convert remaining content
    let html = markdownToHtml(txt);

    console.log(html);
    el.innerHTML = html;
  });
  // syntax-highlight elements that contain a string like
  //   -- CODE language-foo optional additional classes --
  // if we're working with a raw webflow rtf field, we want
  // to grab matching <p> elements. if we're working with
  // html that we've run through showdown, we want to grab
  // matching <code> elements
  //   let snips = $('p:contains("CODE"),code:contains("CODE")');

  function contains(selector, text) {
    const elements = document.querySelectorAll(selector);

    return [].filter.call(elements, (element) => {
      return RegExp(text).test(element.textContent);
    });
  }

  let p = contains('p', 'CODE');
  let code = contains('code', 'CODE');
  let snips = [].concat(p, code);

  snips.forEach(formatCode);
  hljs.registerLanguage('javascript', javascript);
  hljs.registerLanguage('swift', swift);
  hljs.highlightAll();

  let gists = contains('p', 'GIST');
  gists.forEach(loadGist);

  const observer = new IntersectionObserver((entries) => {
    entries.forEach((entry) => {
      const id = entry.target.getAttribute('id');
      if (entry.isIntersecting) {
        document.querySelectorAll('.active').forEach((z) => {
          z.classList.remove('active');
        });
        document.querySelector(`a[href="#${id}"]`).classList.add('active');
      }
    });
  });

  // TOC
  document.querySelectorAll('#content h2').forEach(function (heading, i) {
    // runs a function for all h2 elements inside your rich text element
    observer.observe(heading);
    heading.setAttribute('id', 'toc-' + i); // gives each h2 a unique id
    const item = document.createElement('a'); // creates an anchor element called "item" for each h2
    item.innerHTML = heading.innerHTML; // gives each item the text of the corresponding heading
    item.setAttribute('class', 'tocitem'); // gives each item the correct class
    item.setAttribute('href', '#toc-' + i); // gives each item the correct anchor link
    document.querySelector('#toc-items').appendChild(item); // places each item inside the Table of Contents div
  });

  /* Set Footer Copyright Year */
  function setCopyrightYear() {
    const copyRightYear = document.querySelector('[am-element="copyright-year"]');
    copyRightYear.textContent = new Date().getFullYear();
  }

  setCopyrightYear();
});
